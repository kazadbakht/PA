module ParProRR;

//import * from TestPro;

fimport getNumCapabilities from Control.Concurrent;
fimport unsafePerformIO from System.IO.Unsafe;

// The mutable-array operations
fimport IOArray from Data.Array.IO; // the Array type
fimport newArray_ from Data.Array.IO;
fimport readArray from Data.Array.IO;
fimport writeArray from Data.Array.IO;

// // For generating random numbers
fimport StdGen from System.Random;
fimport mkStdGen from System.Random;
fimport randomR from System.Random;

fimport getTime from System.Clock;
fimport diffTimeSpec from System.Clock;
fimport Clock from System.Clock;
fimport TimeSpec from System.Clock;

// WRITE AND INCLUDE THIS FUNCTION FOR NOW in your module
// this functions computes the difference between two time measurements
def TimeSpec diff(TimeSpec a, TimeSpec b) = diffTimeSpec(a,b);

def Int workers() = unsafePerformIO(getNumCapabilities());         // how many workers (threads) running in parallel

def Int d() = 3;               // the attachment (friendliness) degree

def Int num() = 1000000;         // the maximum people we want to simulate

//def Int num0() = 5;            // how many people in the start

def Int kinit() = d() * (d() + 1); // the given initial "social" connections (cells, edges*2) (the initial social is a complete graph)

def Int graphArraySize() = num() * d() ;          // the size of the graph-array. number-of-edges * 2

def Int workerSize() = ((num()) / workers()) * d(); // the size of the chunk of the graph-array for each worker

def IOArray<Int, Promise<Int>> graphArray() = unsafePerformIO(newArray_(Pair(1, graphArraySize())));

def IOArray<Int, IWorker> workerArray() = unsafePerformIO(newArray_(Pair(0, workers()))); // TODO: it contains an extra element, change it to (1, workers)


interface IWorker {
  Unit run_();
  Unit init_();
}

// interface IPassive {
//   Unit delegate(Promise<Int> ft, Int source, Int target);
// }

// class Passive() implements IPassive {
//     StdGen g = mkStdGen(3);      // does not matter that much what we pass to mkStdGen; the more distinctive number between workers, the better

// }


class Worker(Int f, Int l, Int actNum) implements IWorker {
   Int getsDels = 0;
   StdGen g = mkStdGen(f);      // does not matter that much what we pass to mkStdGen; the more distinctive number between workers, the better
    
	Unit init_() {
	Int index = 0;
	Promise<Int> c;
	if (f == 1)
		index = kinit + 1;
	else
		index = f;

	while (index <= l)
	{
		c = pro_new;
		writeArray(graphArray(), index, c);
		index = index + 1;
	}

	}

   Unit run_() {
       Int i = 1;
       Int temp = f - 1;
       Int j = 0;
       //IPassive p = new local Passive();
	i = d + 2 + (actNum - 1) ; temp = kinit + (actNum - 1) * d;
       // makes new social connections (edges)
	Int numOfNodes = (l - f + 1) / d();
    Int source = 0;
    Int target = 0;
	Int u = 0;
    Int coin = 0;
    Fut<Unit> fi2;
    Promise<Int> c;
    Bool b = False;
    Pair<Int,StdGen> pair__ = Pair(source,this.g);
       while (i <= num) {
           j = 1;
           source = 0;
           target = 0;
	       u = 0;
           while (j <= d()) {
               pair__ = randomR(Pair(1,temp), this.g);
               source = fst(pair__);
               target = temp + j;
		u = 0;
        pair__ = randomR(Pair(0,1), snd(pair__));
		coin  = fst(pair__);
        this.g = snd(pair__);
		if (coin == 0){
			if (source > kinit())
				u = (source - 1) / d() + 1;
			else 
			{
				c = readArray(graphArray(), source);
				u = c.pro_get;
				if (u == -1)
					j = j - 1;
				else
					u = (source - 1) / d() + 1;

			}
		
		}
		else
		{
			c = readArray(graphArray, source);
			b = c.pro_isempty;
			if (b) {
                getsDels = getsDels + 1;
				this ! delegate(c, source, target);
			}
			else{
				u = c.pro_get;
				if (u == -1) j = j - 1;}
		}

		if (u > 0) {
		    Int k = temp + 1;
		    Bool isConflict = False;
		    while (k < target) {
			c  = readArray(graphArray(), k);
			k = k + 1;
			b = c.pro_isempty;
			if (not(b)) {		// redundant
				coin = c.pro_get;
				if (u == coin) {
					isConflict = True;
					k = target;
				}
			}
		    }
		    if (isConflict) //redundant assignment to isConflict at the begining each time
			{j = j - 1;}
		    else {
		    	c = readArray(graphArray(), target);
		    	c.pro_give(u);
		    }
		}	
		j = j + 1;
           }
	  i = i + workers;
	  temp = temp + d * workers ;
	 
       }
       // one while loops to synchronize
       await (this.getsDels == 0);

   }

    Unit delegate(Promise<Int> ft, Int source, Int target) {
        await ft$;
        Int u = ft.pro_get;
        Bool b = this.conflictCheck(u, target);
        if (b) {
		    u = ((target - 1)/d()) * d();
            Pair<Int,StdGen> pair__ = randomR(Pair(1,u), this.g);
		    u = fst(pair__);
            this.g = snd(pair__);
     	   	Promise<Int> c = readArray(graphArray, u);
           	this.delegate(c, u, target);
        }
        else {
		    Promise<Int> c = readArray(graphArray, target);
		    c.pro_give(u);
            getsDels = getsDels -1;
        }

    }
    Bool conflictCheck(Int value, Int target) {
        Int i = ((target - 1)/d()) * d() + 1;
        Int lCurrentNode = i + d() - 1;
        Int item = 0;
        Bool found = False;
        Bool b = False;
        Int v = 0;
        Promise<Int> c;
        while (i <= lCurrentNode) {
	        c = readArray(graphArray(), i);
	        b = c.pro_isempty;
	        if (not(b)) {
		        v = c.pro_get;
        	    if (value == v) {
                  	found = True;
                  	i = lCurrentNode + 1; //just to break the while
		        }
            }
            i = i + 1;
        }
        return found;
    }


}


{
 // init-clique initializes the started complete sub-graph
 Int index = 1;
 Int i = 1;                     // i is for the 1st-loop
 Int j = 0;                     // j is for the 2nd-loop
 Fut<Unit>  fu;                 // each edge created is (i,j)
 Promise<Int> c;

 i = 0;
 while (i <= d()) {
     j = 1;
     while (j <= d()) {
	c = pro_new;
	index = j + (i * d());
	if (j <= i) c.pro_give(j); else c.pro_give(-1);
        writeArray(graphArray(), index, c);
	j = j + 1;
     }
     i = i + 1;
 }

 i = 1;
 IWorker w;
 Int l = 0;
 Int f = 0;
 while (i<workers()) {
     f = (i-1) * workerSize() + 1;
     l = i * workerSize();
     w = new Worker(f, l, i);
     writeArray(workerArray(), i-1, w);
	 i = i + 1;
 }

 w = new Worker(l + 1, graphArraySize(), i);
 writeArray(workerArray(), workers()-1, w);


 IOArray<Int, Fut<Unit>> syncArray = newArray_(Pair(0, workers())); // TODO: also has to change to (0, workers)

//Start initialization of the array in a parallel way

 Fut<Unit> ff;
i = 0;
 while (i < workers) {
     w = readArray(workerArray(),i);
	 ff = w ! init_();
     writeArray(syncArray, i, ff);
	 i = i + 1;
 }


// wait for workers to make sure all the array is initialized

 i = 0;
 while (i < workers) {
     ff = readArray(syncArray, i);
	 ff.get;
	 i = i + 1;
 }
 println("START RUNNING");
  TimeSpec t1 = getTime(Monotonic); // getTime(Monotonic) takes a measurement
 // run workers
i = 0;
 while (i < workers) {
     w = readArray(workerArray(),i);
	 ff = w ! run_();
     writeArray(syncArray, i, ff);
	 i = i + 1;
 }
 // wait for workers

 i = 0;
 while (i < workers) {
     ff = readArray(syncArray, i);
	 ff.get;
	 i = i + 1;
 }
  TimeSpec t2 = getTime(Monotonic);

  TimeSpec t3 = diff(t2,t1);    //  compute the difference       (t2 - t1)

  println(toString(t3));  

}

module PAinit;

fimport IOArray from Data.Array.IO; // the Array type
fimport newArray_ from Data.Array.IO;
fimport readArray from Data.Array.IO;
fimport writeArray from Data.Array.IO;
fimport randomRIO from System.Random; // randomRIO :: Pair<Low,High> -> IO a

// it thinks this is of a value type and has to be initialised 
//type Array<A> = IOArray<Int,A>; // type synonym of arrays indexed by Integers



interface IPAWorker {
    Unit run_();
    Int request(Int source);
}

class PAWorker(Int f, Int l, IOArray<Int,IPAWorker> actors, Int d, Int m0, Int nodesEachPar, IOArray<Int,ICell> toBeArray, IOArray<Int,Int> toBe2, Int pn) implements IPAWorker {
    // NOTE to KEYVAN: the above f,l,d params passed do not have to be redeclared in ABS
    Int k = 0;
    IOArray<Int,Fut<Int>> gets;
    IOArray<Int,Fut<Unit>> getsDels;
    // this is the init
    {
      // the rest can be omitted
      this.k =m0 * (m0 -1);
    }
    Unit run_() {
        Int workerSize = this.nodesEachPar * 2 * this.d;
        Int i = 1;
        Int temp = 0;
	Int getIndex = 1;
        Int j = 0;
	IPAWorker pw = null;
        Int getBound = (l - f + 1) / 2;
	this.gets = newArray_(Pair(0,getBound));
	this.getsDels = newArray_(Pair(0,getBound));
        while (i <= (this.l - this.f + 1) / (2 * this.d)) {
            temp = this.f - 1 + (i-1) * (2 * this.d);
            j = 2;
            Int source = 0;
            Int target = 0;
            while (j <= 2 * this.d) {
		//println(toString(temp));
                source = randomRIO(Pair(1,temp));
		//println(toString(source));
		//println(" ");
                target = temp + j;
		Int srcIndex = (source - this.k - 1)/workerSize;
		if (srcIndex < 0) { srcIndex = 0; }
		if (srcIndex > pn) srcIndex = pn;
		//println(toString(target));
		//println(" ");
		//println(toString(temp));
		//println(" ");
		//println(toString(srcIndex));
		//println("\n");
             	pw = readArray(actors, srcIndex);
                Fut<Int> fi = pw ! request(source);
		writeArray(this.gets, getIndex, fi);
                IPassiveActor pactor;
                pactor = new local PassiveActor(this.f,this.d,this.k);
                Fut<Unit> fi2 = pactor ! delegate(fi, source, target, this.toBeArray, this.toBe2, workerSize, this.actors, pn);
		writeArray(this.getsDels, getIndex, fi2);
                j = j + 2;
		getIndex = getIndex + 1;
            }
            i = i + 1;
        }
	i = 1;
        while (i <= getBound) {
          Fut<Int> f = readArray(gets, i);
	  await f?;
	  i = i + 1;
        }
	//println(toString(i - 1));
	//println("VVV\n");
	i = 1;
        while (i <= getBound) {
          Fut<Unit> f = readArray(getsDels, i);
	  await f?;
	  i = i + 1;
        }

	//i = f;

    }
            
    Int request(Int source) {
  	ICell c = readArray(toBeArray, source);
    	Fut<Int> f = c ! take();
    	await f?;
    	return f.get;
    }
}

interface IPassiveActor {
    Unit delegate(Fut<Int> ft, Int source, Int target, IOArray<Int,ICell> toBeArray, IOArray<Int,Int> toBe2, Int workerSize, IOArray<Int,IPAWorker> actor, Int pn);
    Bool conflictCheck_(Int value, Int target, IOArray<Int,ICell> toBeArray, IOArray<Int,Int> toBe2, Int pn);
}


class PassiveActor(Int f, Int d, Int k) implements IPassiveActor {
    Unit delegate(Fut<Int> ft, Int source, Int target, IOArray<Int,ICell> toBeArray, IOArray<Int,Int> toBe2, Int workerSize, IOArray<Int,IPAWorker> actor, Int pn) {
        await ft?;
        Int u = ft.get;
        Bool b = this.conflictCheck_(u, target, toBeArray, toBe2, pn);
        if (b) {
		Int te = f - 1 + ((target-f)/(2*d)) * 2*d;
		Int source = randomRIO(Pair(1,te));
		//println(toString(source));
		//println(" ");
		//println(toString(target));
		//println("++");
		//println(toString(te));
		//println("++");
		//println(toString(source));
		//println("\n");  
		Int srcIndex = (source - this.k - 1)/workerSize;
		if (srcIndex < 0) { srcIndex = 0; }
		if (srcIndex > pn) srcIndex = pn;
		IPAWorker pw = readArray(actor, srcIndex);
            	Fut<Int> ft_ = pw ! request(source);
            	Fut<Unit> fu = this ! delegate(ft_, source, target, toBeArray, toBe2, workerSize, actor, pn);
		await ft_?;
		await fu?;

            }
        else {
		ICell c = readArray(toBeArray, target);
		Fut<Unit> f = c!put_(u);
		//writeArray(toBe2, target, u);
			
        }
	//fv = con!incInc();
	//Int vv = fv.get;
	//println(toString(vv));
	//println("---");
        
    }


  Bool conflictCheck_(Int value, Int target, IOArray<Int,ICell> toBeArray, IOArray<Int,Int> toBe2, Int pn) {
      Int fCurrentNode = this.f + ((target-(this.f))/(2*this.d)) * (2*this.d);
      Int lCurrentNode = fCurrentNode + (2 * this.d) - 1;
      Int i = fCurrentNode + 1;
      Int item = 0;
      Bool found = False;
      Int v = 0;
      while (i <= lCurrentNode) {
	ICell c = readArray(toBeArray, i);
	Fut<Bool> fb = c!hasValue();
	Bool b = fb.get;
	if (b) {
		  Fut<Int> fi = c!take();
		  v = fi.get;
		  //v = readArray(toBe2, i);
        	  if (value == v) {
                  	found = True;
                  	i = lCurrentNode + 1; //just to break the while
		  }
        }
        i = i + 2;
        
      }
      return found;
  }


}


interface ICell {
    Int take();
    Int take2();
    Unit put_(Int value);
    Bool hasValue();
}

class Cell implements ICell {
  Int value = 0; // initialise to 0
  Int take() {
     // this works because because we can
     // await on fields to change without busy-wait
     await (this.value != 0);
     return this.value;
  }
  Unit put_(Int value) {
     this.value = value;
  }
  Int take2() {
     return this.value;
  }
  Bool hasValue() {
	Bool b = False;
     if (this.value != 0) {
     	b = True;
     }
     return b;
  }
}




interface IMain {
    Unit main_();
    Unit initClique();
    Unit initRemain();
}

class Main implements IMain {
    IOArray<Int,ICell> toBeArray;
    /*IOArray<Int,Int> toBe2;
    IOArray<Int,Fut<Unit>> getsMain;
    // You have to manually change this for now and recompile
    Int workers = 16;*/
    Int num = 100000;
    Int m0 = 5;
    Int d = 3;
    Int k = 0;
    Int n = 0;
    //IOArray<Int,IPAWorker> actor;

    Unit main_() {
	// TO NIKOL: AS YOU SEE, BEFORE THE TWO METHODS THAT WE DISCUSSED, THERE ARE JUST SOME ASSIGNMENT INSTRUCTIONS WITH O(1)
      this.k = m0 * (m0 -1);
      this.n = k + (num - m0) * d * 2;
	//println(toString(n));
	//println("\n");
      this.toBeArray = newArray_(Pair(0,n)); // all cell undefined
      /*this.toBe2 = newArray_(Pair(0,n));
      this.actor = newArray_(Pair(0, workers)); // all workers undefined
      this.getsMain = newArray_(Pair(0,workers));
      Int nodesEachPar = (this.num - this.m0) / this.workers;
      Int i = 1;
      IPAWorker w;
      Int l = k;
      while (i<this.workers) {
          Int f = k + (i -1) * nodesEachPar * (2 * d) + 1;
	  //println(toString(f));
	  //println("\n");
          l = k + i * nodesEachPar * (2 * d);
          w = new PAWorker(f, l, actor, this.d, this.m0, nodesEachPar, toBeArray, toBe2, workers - 1);
          writeArray(this.actor, i-1, w);
	  i = i + 1;
      }
      w = new PAWorker(l + 1, n, actor, this.d, this.m0, nodesEachPar, toBeArray, toBe2, workers - 1);
      writeArray(this.actor, workers-1, w);*/
      this.initClique();
      this.initRemain();
      /*i = 0;
      Fut<Unit> ff;
      while (i < workers) {
          w = readArray(this.actor,i);
	  ff = w ! run_();
          writeArray(getsMain, i, ff);
	  i = i + 1;
      }
      i = 0;
      while (i < workers) {
          ff = readArray(getsMain, i);
	  Unit a = ff.get;
	i = i + 1;
      }
      i = 1;*/
      //while (i <= n) {
	//ICell cc = readArray(toBeArray, i);
	//Fut<Int> fff = cc!take2();
	//Int jjj = fff.get;
	//jjj = readArray(toBe2, i);
	//println(toString(jjj));
	//println("\n");
        //i = i + 1;
      //}
	

    }
    Unit initClique() {
        Int index = 1;
        Int i = 1;
        Int j = 0;
        Fut<Unit>  fu;
        while (i <= this.m0 -1) {
            j = i + 1;
            while (j <= this.m0) {
            	ICell c = new Cell();
            	fu = c!put_(i);
            	fu.get;
                writeArray(this.toBeArray, index, c);
		//writeArray(this.toBe2, index, i);
                index = index + 1;
                c = new Cell();
                fu = c!put_(j);
                fu.get;
                writeArray(this.toBeArray, index, c);
		//writeArray(this.toBe2, index, j);
                index = index + 1;
                j = j + 1;
            }
            i = i + 1;
        }
    }

    Unit initRemain() {
     Int temp = this.k + 1;
     Int i = this.m0 + 1;
     Int j = 1;
     while (i <= this.num) {
	    j = 1;
        while (j <= d) {
             ICell c = new Cell();
             Fut<Unit> f = c!put_(i);
             f.get;
             writeArray(toBeArray, temp, c);
	     //writeArray(this.toBe2, temp, i);
	     c = new Cell();
	     f = c!put_(0);
             f.get;
	     temp = temp + 1;
	     writeArray(toBeArray, temp, c);
	     //writeArray(this.toBe2, temp, 0);
             temp = temp + 1;
             j = j + 1;
        }
        i = i + 1;
    }
    i = 1;
    //println(toString(n));
    //while (i <= this.n)
    //{
	//ICell yy = readArray(toBeArray, i);
	//Fut<Int> f =  yy!take2();
	//Int ii = f.get;
	//println(toString(ii));
	//i = i + 1;
    //}
   }
}


{
 IMain m = new local Main();
 m.main_();
}
